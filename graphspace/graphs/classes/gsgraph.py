import networkx as nx
import re
from django.utils.datetime_safe import datetime



class GSGraph(nx.DiGraph):
	ALLOWED_NODE_SHAPES = ['rectangle', 'roundrectangle', 'ellipse', 'triangle',
						   'pentagon', 'hexagon', 'heptagon', 'octagon', 'star',
						   'diamond', 'vee', 'rhomboid']

	ALLOWED_NODE_BORDER_STYLES = ['solid', 'dotted', 'dashed', 'double']

	ALLOWED_NODE_BACKGROUND_REPEAT = ['no-repeat', 'repeat-x', 'repeat-y', 'repeat']

	ALLOWED_NODE_TEXT_TRANSFORM = ['none', 'uppercase', 'lowercase']

	ALLOWED_NODE_TEXT_WRAP = ['none', 'wrap']

	ALLOWED_TEXT_BACKROUND_SHAPE = ['rectangle', 'roundrectangle']

	ALLOWED_TEXT_HALIGN = ['left', 'center', 'right']

	ALLOWED_TEXT_VALIGN = ['top', 'center', 'bottom']

	## See http://js.cytoscape.org/#style/labels
	ALLOWED_TEXT_WRAP = ['wrap', 'none']

	## See http://js.cytoscape.org/#style/edge-arrow
	ALLOWED_ARROW_SHAPES = ['tee', 'triangle', 'triangle-tee', 'triangle-backcurve',
							'square', 'circle', 'diamond', 'none']

	## See http://js.cytoscape.org/#style/edge-line
	ALLOWED_EDGE_STYLES = ['solid', 'dotted', 'dashed']

	ALLOWED_ARROW_FILL = ['filled', 'hollow']

	NODE_COLOR_ATTRIBUTES = ['background_color', 'border_color', 'color',
							 'text_outline_color', 'text_shadow_color',
							 'text_border_color']

	EDGE_COLOR_ATTRIBUTES = ['line_color', 'source_arrow_color',
							 'mid_source_arrow_color', 'target_arrow_color',
							 'mid_target_arrow_color']

	def __init__(self, *args, **kwargs):
		super(GSGraph, self).__init__(*args, **kwargs)
		self.json = self.compute_json()
		self.set_name('Graph '+ datetime.now().strftime("%I:%M%p on %B %d, %Y"))

	def compute_json(self):

		self.json = {
			'metadata': self.graph,
			'graph': {
				'nodes': [{"data": node[1]} for node in self.nodes(data=True)],
				'edges': [{"data": edge[2]} for edge in self.edges(data=True)],
			}
		}

		return self.json

	def get_json(self):
		return self.json

	def set_json(self, json):
		self.json = json

	def get_name(self):
		return self.graph.get("name", None)

	def set_name(self, name):
		return self.graph.update({"name": name})

	def get_metadata(self):
		return self.graph

	def set_metadata(self, metadata=dict()):
		self.graph.update(metadata)

	def get_tags(self):
		return self.graph.get("tags", [])

	def set_tags(self, tags):
		return self.graph.update({"tags": tags})

	def add_edge(self, source, target, attr_dict=None):
		attr_dict = {} if attr_dict is None else attr_dict
		attr_dict.update({"source": source, "target": target})
		GSGraph.validate_edge_properties(edge_properties=attr_dict, nodes_list=self.nodes())
		super(GSGraph, self).add_edge(source, target, attr_dict)

	def add_node(self, node_name, attr_dict=None):
		attr_dict = {} if attr_dict is None else attr_dict
		attr_dict.update({"name": node_name, "id": node_name})
		GSGraph.validate_node_properties(node_properties=attr_dict, nodes_list=self.nodes())
		super(GSGraph, self).add_node(node_name, attr_dict)

	####################################################################
	### NODE PROPERTY FUNCTIONS #################################################

	def construct_node_properties_dict(self, node_id, label='', shape='ellipse', color='#FFFFFF', height=None, width=None, popup=None,
									k=None, bubble=None, valign='center', halign='center', style="solid",
									border_color='#000000', border_width=1):
		"""
		Constructs the node property dict. This dict is used to set the node property in functiosn like add_node.
		Parameters
		----------
		label: string -- text to display on node. "\n" will be interpreted as a newline. Default = empty string.
		shape: string -- shape of node. Default = "ellipse".
		color: string -- hexadecimal representation of the color (e.g., #FFFFFF) or color name. Default = white.
		height: int -- height of the node's body. Use None to determine height from the number of lines in the label. Default = None.
		width: int -- width of the node's body, or None to determine width from length of label.  Default=None.
		popup: string -- Information (in HTML format) to display when this node is selected in GraphSpace. Optional.
		k: int -- value for filtering nodes and edges in graph. This parameter is useful for graphs generated by the Linker algorithm (http://www.ncbi.nlm.nih.gov/pubmed/23641868). Here k is the index of the first path in which a node or edge appears. Optional.
		bubble: string -- color of the text outline. Using this option gives a "bubble" effect; see the bubbleeffect() function. Optional.
		valign: string -- vertical alignment. Default = center.
		halign: string -- horizontal alignment. Default = center.
		style: string -- style of border. Default is "solid".  If Bubble is specified, then style is overwritten.
		border_color: string -- color of border. Default is #000000. If Bubble is specified, then style is overwritten.
		border_width: int -- width of border. Default is 4.  If Bubble is specified, then style is overwritten.

		Returns
		-------
		Dictionary of node attributes.

		"""
		node_properties = {}
		node_properties = GSGraph.set_node_name_property(node_properties, node_id)
		node_properties = GSGraph.set_node_id_property(node_properties, node_id)
		node_properties = GSGraph.set_node_label_property(node_properties, label)
		node_properties = GSGraph.set_node_shape_property(node_properties, shape)
		node_properties = GSGraph.set_node_color_property(node_properties, color)
		node_properties = GSGraph.set_node_width_property(node_properties, width)
		node_properties = GSGraph.set_node_height_property(node_properties, height)
		node_properties = GSGraph.set_node_vertical_alignment_property(node_properties, valign)
		node_properties = GSGraph.set_node_horizontal_alignment_property(node_properties, halign)
		node_properties = GSGraph.set_node_border_style_property(node_properties, style)
		node_properties = GSGraph.set_node_border_color_property(node_properties, border_color)
		node_properties = GSGraph.set_node_border_width_property(node_properties, border_width)

		if popup:
			node_properties = GSGraph.set_node_popup_property(node_properties, popup)
		if k:
			node_properties = GSGraph.set_node_k_property(node_properties, k)
		# If bubble is specified, use the provided color,
		if bubble:
			node_properties = GSGraph.set_node_bubble_effect_property(node_properties, bubble, whitetext=False)

		## set height and width if len(label)==0 and height/width
		## are None (auto-resize).  Make them very small nodes.
		## height=width=5
		if (not width or not height) and len(label) == 0:
			node_properties = GSGraph.set_node_width_property(node_properties, 5, label)
			node_properties = GSGraph.set_node_height_property(node_properties, 5, label)

		return node_properties

	@staticmethod
	def set_node_name_property(node_properties, name):
		"""
		Set the name to a "node_properties" dict and return the "node_properties" dict.

		Parameters
		----------
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.
		name - name of the node.

		Returns
		-------
		Dictionary of node attributes.

		"""
		node_properties.update('name', name)
		return node_properties

	@staticmethod
	def set_node_id_property(node_properties, id):
		"""
		Set the id to a "node_properties" dict and return the "node_properties" dict.

		Parameters
		----------
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.
		id - id of the node.

		Returns
		-------
		Dictionary of node attributes.

		"""
		node_properties.update('id', id)
		return node_properties

	@staticmethod
	def set_node_label_property(node_properties, label):
		"""
		Set the label "label" to a "node_properties" dict and return the "node_properties" dict.
		The label is stored under "content" in the node information. Also set wrap = 'wrap' so newlines are interpreted.

		Parameters
		----------
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.
		label - text to display on node. "\n" will be interpreted as a newline.

		Returns
		-------
		Dictionary of node attributes.

		"""
		node_properties.update('content', label)
		node_properties = GSGraph.set_node_wrap_property(node_properties, 'wrap')
		return node_properties

	@staticmethod
	def set_node_label_property(node_properties, label):
		"""
		Set the label "label" to a "node_properties" dict and return the "node_properties" dict.
		The label is stored under "content" in the node information. Also set wrap = 'wrap' so newlines are interpreted.

		Parameters
		----------
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.
		label - text to display on node. "\n" will be interpreted as a newline.

		Returns
		-------
		Dictionary of node attributes.

		"""
		node_properties.update('content', label)
		node_properties = GSGraph.set_node_wrap_property(node_properties, 'wrap')
		return node_properties

	@staticmethod
	def set_node_wrap_property(node_properties, wrap):
		"""
		Adding node wrap allows the newline '\n' to be interpreted as a line break for the node.

		Parameters
		----------
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.
		wrap - string denoting the type of wrap: one of "wrap" or "none".

		Returns
		-------
		Dictionary of node attributes.

		Raises
		-------

		Exception - if the wrap parameter is not one of the allowed wrap styles. See ALLOWED_NODE_TEXT_WRAP for more details.

		"""
		if wrap not in GSGraph.ALLOWED_NODE_TEXT_WRAP:
			raise Exception('"%s" is not an allowed text wrap style.' % (wrap))
		node_properties.update('text_wrap', wrap)
		return node_properties

	@staticmethod
	def set_node_shape_property(node_properties, shape):
		"""
		Add a shape property "shape" to the node_properties.

		Parameters
		----------
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.
		shape - string -- shape of node. Default = "ellipse".

		Returns
		-------
		Dictionary of node attributes.

		Raises
		-------

		Exception - if the shape is not one of the allowed node shapes. See ALLOWED_NODE_SHAPES global variable.

		"""
		if shape not in GSGraph.ALLOWED_NODE_SHAPES:
			raise Exception('"%s" is not an allowed shape.' % (shape))
		node_properties.update('shape', shape)
		return node_properties

	@staticmethod
	def set_node_color_property(node_properties, color):
		"""
		Add a background color to the node_properties.
		Color can be a name (e.g., 'black') or an HTML string (e.g., #00000).


		Parameters
		----------
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.
		color - string -- hexadecimal representation of the color (e.g., #FFFFFF) or color name.

		Returns
		-------
		Dictionary of node attributes.

		Raises
		-------

		Exception - if the color is improperly formatted.

		"""
		error = GSGraph.check_color_hex(color)
		if error is not None:
			raise Exception(error)
		node_properties.update('background_color', color)
		return node_properties

	@staticmethod
	def set_node_height_property(node_properties, height, label, height_factor=20):
		"""
		Add a node height property to the node_properties.
		If the height is 'None', then the height of the node is determined by the number of newlines in the label that will be displayed.

		Parameters
		----------
		height_factor - factor to multiply the height of the label. Default is 20.
		label - string -- text to display on node. "\n" will be interpreted as a newline. Use for auto-resizing when height = None.
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.
		height - int -- height of the node's body. Use None to determine height from the number of lines in the label.

		Returns
		-------
		Dictionary of node attributes.

		"""
		if height == None: # "auto-resize" height
			#  take the number of lines for the label after interpreting newlines.
			labellines = label.split('\n')
			height = len(labellines)*height_factor

		node_properties.update('height', height)
		return node_properties

	@staticmethod
	def set_node_width_property(node_properties, width, label, width_factor=15):
		"""
		Add a node width property to the node_properties.
		If the width is 'None', then the width of the node is determined by the length (number of characters) in the longest  line in the label that will be displayed.

		Parameters
		----------
		width_factor - factor to multiply the width of the label. Default is 15.
		label - string -- text to display on node. "\n" will be interpreted as a newline. Used for auto-resizing when width=None.
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.
		width - int -- width of the node's body, or None to determine width from length of label.

		Returns
		-------
		Dictionary of node attributes.

		"""
		if width == None:
			## take the longest width of the label after interpreting newlines.
			labellines = label.split('\n')
			width = max([len(l) for l in labellines])*width_factor
		node_properties.update('width', width)
		return node_properties


	@staticmethod
	def set_node_popup_property(node_properties, popup):
		"""
		Add an HTML-formatted string with information on node "node_id" in graph "G".
		When the user clicks the node in GraphSpace, this string will appear in a pop-up panel.

		Parameters
		----------
		popup - string -- Information (in HTML format) to display when this node is selected in GraphSpace.
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.

		Returns
		-------
		Dictionary of node attributes.

		"""
		node_properties.update('popup', popup)
		return node_properties

	@staticmethod
	def set_node_k_property(node_properties, k):
		"""
		Add a value (k) to filter the node  to node "node_id" in graph "G".
		In GraphSpace, a user may adjust a slider.  For a slider value x, only nodes with k-value less than or equal to x are displayed.

		Nodes without a k value will always be displayed.
		This function may be overridden to pass a non-integer; in this case, k is set to the floor of the decimal value.

		Parameters
		----------
		k - int -- value for filtering nodes in graph.
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.

		Returns
		-------
		Dictionary of node attributes.

		"""
		node_properties.update('k', k)
		return node_properties


	@staticmethod
	def set_node_bubble_effect_property(node_properties, color,whitetext=False):
		"""
		Add a "bubble effect" to the node by making the
		border color the same as the text outline color.

		Parameters
		----------
		whitetext - Boolean -- if True, text is colored white instead of black. Default is False.
		color - string -- hexadecimal representation of the text outline color (e.g., #FFFFFF) or a color name.
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.

		Returns
		-------
		Dictionary of node attributes.

		"""
		node_properties.update('text_outline_color', color)
		node_properties = GSGraph.set_node_border_color_property(node_properties, color)
		# also make outline thicker and text larger
		node_properties.update('text_outline_width', 4)
		if whitetext:
			node_properties.update('color', 'white')
		return node_properties

	@staticmethod
	def set_node_border_width_property(node_properties, border_width):
		"""
		Set the border width in node_properties.

		Parameters
		----------
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.

		Returns
		-------
		Dictionary of node attributes.

		"""
		node_properties.update('border_width', border_width)
		return node_properties


	@staticmethod
	def set_node_border_style_property(node_properties, border_style):
		"""
		Set the border width in node_properties.

		Parameters
		----------
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.

		Returns
		-------
		Dictionary of node attributes.

		Raises
		-------

		Exception - if the border_style parameter is not one of the allowed border styles. See ALLOWED_NODE_BORDER_STYLES for more details.


		"""
		if border_style not in GSGraph.ALLOWED_NODE_BORDER_STYLES:
			raise Exception('"%s" is not an allowed node border style.' % (border_style))
		node_properties.update('border_style', border_style)
		return node_properties

	@staticmethod
	def set_node_border_color_property(node_properties, border_color):
		"""
		Set the border_color in node_properties.

		Parameters
		----------
		color - string -- hexadecimal representation of the text outline color (e.g., #FFFFFF) or a color name.
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.

		Returns
		-------
		Dictionary of node attributes.

		Raises
		-------

		Exception - if the border_color is improperly formatted.


		"""
		error = GSGraph.check_color_hex(border_color)
		if error is not None:
			raise Exception(error)
		node_properties.update('border_color', border_color)
		return node_properties

	@staticmethod
	def set_node_vertical_alignment_property(node_properties, valign):
		"""
		Set the vertical alignment of label in node_properties.

		Parameters
		----------
		valign - string -- alignment of text.
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.

		Returns
		-------
		Dictionary of node attributes.

		"""

		node_properties.update('text_valign', valign)
		return node_properties

	@staticmethod
	def set_node_horizontal_alignment_property(node_properties, halign):
		"""
		Set the horizontal alignment of label in node_properties.

		Parameters
		----------
		valign - halign -- alignment of text.
		node_properties - Dictionary of node attributes.  Key/value pairs will be used to set data associated with the node.

		Returns
		-------
		Dictionary of node attributes.

		"""

		node_properties.update('text_halign', halign)
		return node_properties

	def get_node_attribute(self, node_id, attr):
		'''
		Get a node attribute, or None if no attribute exists.
		'''
		if attr in self.node[node_id]:
			return self.node[node_id][attr]
		else:
			return None

	def get_node_label_property(self, node_id):
		return self.get_node_attribute(node_id,'content')

	def get_node_wrap_property(self, node_id):
		return self.get_node_attribute(node_id,'text_wrap')

	def get_node_shape_property(self, node_id):
		return self.get_node_attribute(node_id,'shape')

	def get_node_color_property(self, node_id):
		return self.get_node_attribute(node_id,'background_color')

	def get_node_height_property(self, node_id):
		return self.get_node_attribute(node_id,'height')

	def get_node_width_property(self, node_id):
		return self.get_node_attribute(node_id, 'width')

	def get_node_popup_property(self, node_id):
		return self.get_node_attribute(node_id,'popup')

	def get_node_k_property(self, node_id):
		return self.get_node_attribute(node_id,'k')

	def get_node_border_width_property(self, node_id):
		return self.get_node_attribute(node_id,'border_width')

	def get_node_border_style_property(self, node_id):
		return self.get_node_attribute(node_id,'border_style')

	def get_node_border_color_property(self, node_id):
		return self.get_node_attribute(node_id,'border_color')

	def get_node_vertical_alignment_property(self, node_id):
		return self.get_node_attribute(node_id,'text_valign')

	def get_node_horizontal_alignment_property(self, node_id):
		return self.get_node_attribute(node_id,'text_halign')

	@staticmethod
	def validate_node_properties(node_properties, nodes_list=[]):
		"""
		Validates node properties. For example, we no more require all nodes to have a id. But we require all nodes to have a name.

		Parameters
		----------
		nodes_list: list of unique nodes in the Graph. We need this to check the uniqueness of node names.

		Returns
		-------
		None - if node_properties are valid

		Raises
		_______
		Raises an exception - if properties are not valid.

		"""

		error_list = []

		# Check to see if name is in node_properties
		if "name" not in node_properties:
			raise Exception("All nodes must have a unique name.  Please verify that all nodes meet this requirement.")

		# Check the data type of node_properties, should be int, float or string
		if not isinstance(node_properties["name"], (basestring, int, float)):
			raise Exception("All nodes must be strings, integers or floats")

		if node_properties["name"] in nodes_list:
			raise Exception("There are multiple nodes with name: " + str(
				node_properties["name"]) + ".  Please make sure all node names are unique.")

		# This list contains tuple values (property_name, allowed_property_values) where property_name is the name of the property to be checked and
		# allowed_property_values is the list of allowed or legal values for that property.
		node_validity_checklist = [
			("shape", GSGraph.ALLOWED_NODE_SHAPES),
			("border_style", GSGraph.ALLOWED_NODE_BORDER_STYLES),
			("background_repeat", GSGraph.ALLOWED_NODE_BACKGROUND_REPEAT),
			("text_transform", GSGraph.ALLOWED_NODE_TEXT_TRANSFORM),
			("text_wrap", GSGraph.ALLOWED_NODE_TEXT_WRAP),
			("text_background_shape", GSGraph.ALLOWED_NODE_SHAPES),
			("text_halign", GSGraph.ALLOWED_TEXT_HALIGN),
			("text_valign", GSGraph.ALLOWED_TEXT_VALIGN)
		]

		for property_name, allowed_property_values in node_validity_checklist:
			error = GSGraph.validate_property(node_properties, "Node", node_properties["name"], property_name,
											  allowed_property_values)
			if error is not None:
				error_list.append(error)

		# If node_properties contains a background_black property, check to make sure they have values [-1, 1]
		if "border_blacken" in node_properties and -1 <= node_properties["border_blacken"] <= 1:
			error_list.append("Node: " + str(
				node_properties["name"]) + " contains illegal border_blacken value.  Must be between [-1, 1].")

		for attr in GSGraph.NODE_COLOR_ATTRIBUTES:
			if attr in node_properties:
				error = GSGraph.check_color_hex(node_properties[attr])
				if error is not None:
					error_list.append(error)

		if len(error_list) > 0:
			raise Exception(", ".join(error_list))
		else:
			return None

	####################################################################
	### EDGE PROPERTY FUNCTIONS #################################################

	def construct_edge_properties_dict(self, source, target, color='#000000',directed=False,width=1.0,popup=None,k=None,arrow_shape='triangle',edge_style='solid',arrow_fill='filled'):
		"""
		Constructs the edge property dict. This dict is used to set the edge property in functions like add_edge.
		Parameters
		----------
		source: string -- unique ID of the source node
		target: string -- unique ID of the target node
		color: string -- hexadecimal representation of the color (e.g., #000000), or the color name. Default = black.
		directed: bool - if True, draw the edge as directed. Default = False.
		width: float -- width of the edge.  Default = 1.0
		popup: string -- Information (in HTML format) to display when this edge is selected in GraphSpace. Optional.
		k: int -- value for filtering nodes and edges in graph. This parameter is useful for graphs generated by the Linker algorithm (http://www.ncbi.nlm.nih.gov/pubmed/23641868). Here k is the index of the first path in which a node or edge appears. Optional.
		arrow_shape: string -- shape of arrow head. Default is "triangle"
		edge_style: string -- style of edge. Default is "solid"
		arrow_fill: string -- fill of arrow. Default is "filled"

		Returns
		-------
		Dictionary of node attributes.

		"""
		edge_properties = {}
		edge_properties.update({"source": source, "target": target})
		edge_properties = GSGraph.set_edge_color_property(edge_properties, color)
		edge_properties = GSGraph.set_edge_width_property(edge_properties, width)
		edge_properties = GSGraph.set_edge_target_arrow_shape_property(edge_properties, arrow_shape)
		edge_properties = GSGraph.set_edge_line_style_property(edge_properties, edge_style)
		edge_properties = GSGraph.set_edge_target_arrow_fill(edge_properties, arrow_fill)
		if popup:
			edge_properties = GSGraph.set_edge_popup_property(edge_properties, popup)
		if k:
			edge_properties = GSGraph.set_edge_k_property(edge_properties, self.get_node_k_property(source), self.get_node_k_property(target), k, source, target)

		return edge_properties

	@staticmethod
	def set_edge_color_property(edge_properties, color):
		"""
		Add a edge color to the edge_properties.

		Color both the line and the target arrow; if the edge
		is undirected, then the target arrow color doesn't matter.
		If it's directed, then the arrow color will match the line color.

		Color can be a name (e.g., 'black') or an HTML string (e.g., #00000).

		Parameters
		----------
		edge_properties - Dictionary of edge attributes.  Key/value pairs will be used to set data associated with the edge.
		color - string -- hexadecimal representation of the color (e.g., #FFFFFF) or color name.

		Returns
		-------
		Dictionary of edge attributes.

		Raises
		-------

		Exception - if the color is improperly formatted.

		"""
		error = GSGraph.check_color_hex(color)
		if error is not None:
			raise Exception(error)

		edge_properties.update('line_color', color)
		edge_properties.update('target_arrow_color', color)
		return edge_properties


	@staticmethod
	def set_edge_directionality_property(edge_properties, directed, arrow_shape='triangle'):
		"""
		Sets a "directed" flag as well as adds a target arrow shape.

		Parameters
		----------
		edge_properties - Dictionary of edge attributes.  Key/value pairs will be used to set data associated with the edge.
		directed - bool - if True, draw the edge as directed.
		arrow_shape - string -- shape of arrow. See ALLOWED_ARROW_SHAPES.

		Returns
		-------
		Dictionary of edge attributes.

		"""
		if directed:
			edge_properties.update('directed', 'true')
			edge_properties = GSGraph.set_edge_target_arrow_shape_property(edge_properties, arrow_shape)
		else:
			edge_properties.update('directed', 'false')
			edge_properties = GSGraph.set_edge_target_arrow_shape_property(edge_properties, 'none')
		return edge_properties

	@staticmethod
	def set_edge_width_property(edge_properties, width):
		"""
		Sets the width property of the edge.

		Parameters
		----------
		edge_properties - Dictionary of edge attributes.  Key/value pairs will be used to set data associated with the edge.
		width - float -- width of the edge.  Default = 1.0

		Returns
		-------
		Dictionary of edge attributes.

		"""
		edge_properties.update('width', width)
		return edge_properties

	@staticmethod
	def set_edge_popup_property(edge_properties, popup):
		"""
		Add an HTML-formatted string with information on edge.
		When the user clicks the edge in GraphSpace, this string will appear in a pop-up panel.

		Parameters
		----------
		edge_properties - Dictionary of edge attributes.  Key/value pairs will be used to set data associated with the edge.
		popup - string -- Information (in HTML format) to display when this edge is selected in GraphSpace.

		Returns
		-------
		Dictionary of edge attributes.

		"""
		edge_properties.update('popup', popup)
		return edge_properties


	@staticmethod
	def set_edge_k_property(edge_properties, sourcek, targetk, k, source, target):
		"""
		Add a value (k) to filter the edge.
		In GraphSpace, a user may adjust a slider.  For a slider value x, only edges with k-value less than or equal to x are displayed.

		Edges without a k value will always be displayed.

		This function may be overridden to pass a non-integer; in this case, k is set to the floor of the decimal value.

		Parameters
		----------
		edge_properties - Dictionary of edge attributes.  Key/value pairs will be used to set data associated with the edge.
		k - int -- value for filtering nodes in graph.

		Returns
		-------
		Dictionary of edge attributes.

		Raises
		--------
		Exception - if the source and target values have a larger k value than the edge.

		"""
		## Cytoscape.js throws a runtime error if there's an edge with a small k (e.g., 1) but the nodes have larger k's (e.g., 5).
		## When the slider is set to 3, the edge should be displayed but the incident nodes are not.
		if not sourcek:
			raise Exception('Attempting to add a k value %d for edge ("%s","%s"), but node "%s" does not have a k-value.' % (k,source,target,source))
		if not targetk:
			raise Exception('Attempting to add a k value %d for edge ("%s","%s"), but node "%s" does not have a k-value.' % (k,source,target,target))
		if sourcek > k:
			raise Exception('Attempting to add a k value %d for edge ("%s","%s"), but node "%s" has a larger k-value (%d).' % (k,source,target,source,sourcek))
		if targetk > k:
			raise Exception('Attempting to add a k value %d for edge ("%s","%s"), but node "%s" has a larger k-value (%d).' % (k,source,target,target,targetk))

		edge_properties.update('k', k)
		return edge_properties

	@staticmethod
	def set_edge_target_arrow_shape_property(edge_properties, arrow_shape):
		"""
		Assigns an arrow shape to edge

		Parameters
		----------
		edge_properties - Dictionary of edge attributes.  Key/value pairs will be used to set data associated with the edge.

		Returns
		-------
		Dictionary of edge attributes.

		"""
		edge_properties.update('target_arrow_shape', arrow_shape)
		return edge_properties

	@staticmethod
	def set_edge_line_style_property(edge_properties, style):
		"""
		Adds the edge line style to edge

		Parameters
		----------
		edge_properties - Dictionary of edge attributes.  Key/value pairs will be used to set data associated with the edge.
		style - string -- style of line

		Returns
		-------
		Dictionary of edge attributes.

		"""
		edge_properties.update('line_style', style)
		return edge_properties


	@staticmethod
	def set_edge_target_arrow_fill(edge_properties, fill):
		"""
		Adds the arrowhead fill to edge

		Parameters
		----------
		edge_properties - Dictionary of edge attributes.  Key/value pairs will be used to set data associated with the edge.
		fill - string -- fill of arrowhead.

		Returns
		-------
		Dictionary of edge attributes.

		"""
		edge_properties.update('target_arrow_fill', fill)
		return edge_properties

	def get_edge_attribute(self, source, target, attr):
		'''
		Get a edge attribute, or None if no attribute exists.
		'''
		if attr in self.edge[source][target]:
			return self.edge[source][target][attr]
		else:
			return None

	def get_edge_color(self,source,target):
		return self.get_edge_attribute(source,target,'line_color')
	def get_edge_directionality(self,source,target):
		return self.get_edge_attribute(source,target,'directed')
	def get_edge_width(self,source,target):
		return self.get_edge_attribute(source,target,'width')
	def get_edge_popup(self,source,target):
		return self.get_edge_attribute(source,target,'popup')
	def get_edge_k(self,source,target):
		return self.get_edge_attribute(source,target,'k')
	def get_edge_target_arrow_shape(self,source,target):
		return self.get_edge_attribute(source,target,'target_arrow_shape')
	def get_edge_line_style(self,source,target):
		return self.get_edge_attribute(source,target,'line_style')
	def get_edge_target_arrow_fill(self,source,target):
		return self.get_edge_attribute(source,target,'target_arrow_fill')




	@staticmethod
	def validate_edge_properties(edge_properties, nodes_list=[]):
		"""
		Validates all edge properties.

		Parameters
		----------
		nodes_list: list of unique nodes in the Graph. This is required to check if the surce and target nodes exists or not.

		Returns
		-------
		None - if edge properties are valid

		Raises
		_______
		Raises an exception - if properties are not valid.
		"""
		error_list = []

		# Go through all edge properties to verify if edges contain valid properties recognized by CytoscapeJS

		# If edge has no source and target nodes, throw error since they are required
		if "source" not in edge_properties or "target" not in edge_properties:
			raise Exception(
				"All edges must have at least a source and target property.  Please verify that all edges meet this requirement.")

		# Check if source and target node of an edge exist in the node list
		if edge_properties["source"] not in nodes_list or edge_properties["target"] not in nodes_list:
			raise Exception("For all edges source and target nodes should exist in node list")

		# Check if source and target nodes are strings, integers or floats
		if not (
					isinstance(edge_properties["source"], (basestring, int, float)) and isinstance(
					edge_properties["target"],
					(basestring, int, float))):
			raise Exception("Source and target nodes of the edge must be strings, integers or floats")

		edge_name = "with source: " + str(edge_properties["source"]) + "and target: " + str(edge_properties["target"])

		# If edge is directed, it must have a target_arrow_shape
		if "directed" in edge_properties and edge_properties[
			"directed"] == "true" and "target_arrow_shape" not in edge_properties:
			raise Exception("Edge", edge_name, "must have a target_arrow_shape property if directed is set to true")

		# This list contains tuple values (property_name, allowed_property_values) where property_name is the name of the property to be checked and
		# allowed_property_values is the list of allowed or legal values for that property.
		edge_validity_checklist = [
			("source_arrow_shape", GSGraph.ALLOWED_ARROW_SHAPES),
			("mid_source_arrow_shape", GSGraph.ALLOWED_ARROW_SHAPES),
			("target_arrow_shape", GSGraph.ALLOWED_ARROW_SHAPES),
			("mid_target_arrow_shape", GSGraph.ALLOWED_ARROW_SHAPES),
			("line_style", GSGraph.ALLOWED_EDGE_STYLES),
			("source_arrow_fill", GSGraph.ALLOWED_ARROW_FILL),
			("mid_source_arrow_fill", GSGraph.ALLOWED_ARROW_FILL),
			("target_arrow_fill", GSGraph.ALLOWED_ARROW_FILL),
			("mid_target_arrow_fill", GSGraph.ALLOWED_ARROW_FILL)
		]

		for property_name, allowed_property_values in edge_validity_checklist:
			error = GSGraph.validate_property(edge_properties, "Edge", edge_name, property_name,
											  allowed_property_values)
			if error is not None:
				error_list.append(error)

		for attr in GSGraph.EDGE_COLOR_ATTRIBUTES:
			error = GSGraph.check_color_hex(edge_properties[attr]) if attr in edge_properties else None
			if error is not None:
				error_list.append(error)

		if len(error_list) > 0:
			raise Exception(", ".join(error_list))
		else:
			return None

	@staticmethod
	def check_color_hex(color_code):
		"""
		Check the validity of the hexadecimal code of various node and edge color
		related attributes.

		This function returns an error if the hexadecimal code is not of the format
		'#XXX' or '#XXXXXX', i.e. hexadecimal color code is not valid.

		:param color_code: color code
		"""
		# if color name is given instead of hex code, no need to check its validity
		if not color_code.startswith('#'):
			return None
		valid = re.search(r'^#(?:[0-9a-fA-F]{3}){1,2}$', color_code)
		if valid is None:
			return color_code + ' is not a valid hex color code.'
		else:
			return None

	@staticmethod
	def validate_property(element, element_type, element_name, property_name, valid_property_values):
		"""
		Goes through array to see if property is contained in the array.

		Parameters
		----------
		element: Element to search for in network
		element_type: Node or an Edge
		element_name: Key to search for in network
		property_name: name of the property
		valid_property_values: List of valid properties

		Returns
		-------
		None - if the property is valid or does not exist
		Error message - if the property is not valid

		"""
		if property_name in element and element[property_name] not in valid_property_values:
			return element_type + " " + element_name + " contains illegal value for property: " + property_name + ".  Value given for this property was: " + \
				   element[
					   property_name] + ".  Accepted values for property: " + property_name + " are: [" + valid_property_values + "]"

		return None
